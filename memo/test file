# Function

    셸 스크립트에서의 함수
    {;}, ( ) 를 이용해 명령 그룹을 생성해주면 같은 context 에서 실행된다.
    명령그룹 전체가 하나의 명령처럼 실행되는 효과
    앞에 함수명을 붙여서 함수정의를 하여 일반 명령처럼 사용 가능

    {;} : 현재 shell 에서 실행
    ()  : sub shell 에서 실행

    ### 사용법
    - 일반 명령과 동일하다.
    - 종료상태 값 지정은 return 명령으로 한다.
    - shell 에서는 return 명령이 함수에서 연산한 결과를 반환하는 것이 아닌 exit 명령 과 같이
      정상적으로 종료 됐는지 판단하는데 사용한다.

    ### 함수 정의 하는 법 
    - 프로그그래밍 언어 처럼 매개변수를 적지 않는다.
    - 전달되 인수는 함수 내에서 $1, $2, $3 .. 특수 변수에 할당된다.
    - $@, $* :  함수에 전달된 인자들 전부를 포함 
    - 함수명 :
                shell 에서 사용되는 메타문자, quote 사용 불가
                외부명령, alias 와 동일한 이름을 사용할 경우 syntax error 발생할 수 있다.
                 => function 키워드 붙이면 됨. (bash 에서만 됨)

    - 함수를 실행할 땐 먼저 정의가 되어 있어야 한다.

    ### 변수는 기본적으로 global scope
    - global scope : 현재 셸 스크립트 파일 범위

    ### local 명령을 사용하여 지역변수를 설정할 수 있다.
    - local 과 declare 은 동일한 기능을 하지만 local 은 global scope 에서 사용할 수 없습니다.
    - declare 가 함수 내에서 사용되면 local 과 동일한 역할을 합니다.
    > sh 에서는 함수 내에서 local 만 사용할 수 있다.


    ### 스크립트에서 리다이렉션 사용하기

        redirection 기호을 중심으로 왼쪽에 오는 FD 는 명령의 인수로 인식되지 않게 붙여쓰고 
        오른쪽에 오는 FD 는 파일로 인식되지 않게 & 를 붙여 사용하면 됩니다.


        - 스크립트 실행시 fd 0, 1, 2 번은 연결이 터미널이 아닌 파일, 파이프가 될 수 있어
            0, 1, 2, 를 사용하기 전에 백업, 복구 과정을 거쳐야한다.
            백업한 fd 를 삭제할떄는 복구 과정 이후에 - 기호를 붙이면 된다.
            Ex.
                cmd 3>&1 : fd 3 을 1 번에 연결한다. ( 3은 1 번의 연결이 3번에 백업되어있다.)
                
                cmd 1> outfile :    1 번이 outfile 을 가리키도록 한다. 
                                    cmd 의 결과중에서 표준 출력(1)이 있을 경우 outfile 에 출력되도록

                ...             : 이후 표준 출력(1) 은 모두 outfile 로 간다.
                cmd 1>&3-       : 표준출력(1)을 더이상 사용하지 않을 경우 3 을 가리키게 해서 다시 원래의
                                    표준 출력으로 돌아가게 하고 3을 삭제한다. 

# 비교 연산자
    ### 정수 비교

        -eq : 같음
        ``````if [ "$a" -eq "$b" ]``````

        -ne : 같지 않음
        ```if [ "$a" -ne "$b" ]```

        -gt : 더 큼
        ```if ["$a" -gt "$b" ]```

        -ge : 더 크거나 같음
        ```if [ "$a" -ge "$b" ]```

        -lt : 더 작음
        ```if [ "$a" -lt "$b" ]```

        -le : 더 작거나 같음
        ```if [ "$a" -le "$b" ]```

        < : 더 작음(이중 소괄호에서)
        ```(("$a" < "$b"))```

        <= : 더 작거나 같음(이중 소괄호에서)
        ```(("$a" <= "$b"))```

        > : 더 큼(이중 소괄호에서)
        ```(("$a" > "$b"))```

        >= : 더 크거나 같음(이중 소괄호에서)
        ```(("$a" >= "$b"))```

    ### 문자열 비교

    = : 같음
    ```if [ "$a" = "$b" ]```

    == : 같음
    ```if [ "$a" == "$b" ]```

    = 와 동의어입니다
    ```
    [[ $a == z* ]]    # $a 가 "z"로 시작하면 참(패턴 매칭)
    [[ $a == "z*" ]]  # $a 가 z* 와 같다면 참

    [ $a == z* ]      # 파일 globbing이나 낱말 조각남이 일어남
    [ "$a" == "z*" ]  # $a 가 z* 와 같다면 참
    ```
    
    != : 같지 않음
    ```if [ "$a" != "$b" ]```
    > 이 연산자는 [[ ... ]] 에서 패턴 매칭을 사용합니다.

    < : 아스키 알파벳 순서에서 더 작음
    ```if [[ "$a" < "$b" ]]```
    ```if [ "$a" \< "$b" ]```

    > "<" 가 [ ] 에서 쓰일 때는 이스케이프를 시켜야 하는 것에 주의하세요.

    > : 아스키 알파벳 순서에서 더 큼

    ```if [[ "$a" > "$b" ]]```
    ```if [ "$a" \> "$b" ]```

    -z : 문자열이 "null"임. 즉, 길이가 0
    -n : 문자열이 "null"이 아님.